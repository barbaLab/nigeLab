function Y=fastsmooth(X,N,varargin)%% FASTSMOOTH    Smooths vector X%%   Y = FASTSMOOTH(X,N)%%   Y = FASTSMOOTH(X,N,Type)%%   Y = FASTSMOOTH(X,N,Type,Ends)%%	Example:%   fastsmooth([1 1 1 10 10 10 1 1 1 1],3)= [0 1 4 7 10 7 4 1 1 0]%   fastsmooth([1 1 1 10 10 10 1 1 1 1],3,1,1)= [1 1 4 7 10 7 4 1 1 1]%%   --------%    INPUTS%   --------%      X        :       Vector with > N elements.%%      N        :       Window length (scalar, integer) for smoothing.%                       Given as number of indices to smooth over.%%     Type      :       (Optional) Determines smooth type:%                       - 'abs_med' (sliding-absolute-median)%                       - 'med'  (sliding-median)%                       - 'rect' (sliding-average/boxcar)%                       - 'tri'  (def; 2-passes of sliding-average)%                       - 'pg'   (3-passes of sliding-average)%%     Ends      :       (Optional) Controls the "ends" of the signal.%                       (First N/2 points and last N/2 points).%                       - 0 (sets ends to zero; fastest)%                       - 1 (def; progressively smooths ends with shorter%                            widths. can take a long time for long windows)%%   --------%    OUTPUT%   --------%      Y        :       Smoothed (low-pass filtered) version of X. Degree%                       of smoothing depends mostly on window length, and%                       slightly on window type.%% Original version by: T. C. O'Haver, May, 2008. (v2.0)%% Adapted by: Max Murphy 03/14/2017 v3.0 Added argument parsing, changed%                                        defaults, added documentation and%                                        changed variable names for%                                        clarity. (Matlab R2016b)%                        12/28/2017 v3.1 Added "median" smoothing.%% DEFAULTSDEF_TYPE = 'tri';DEF_ENDS = 1;TYPE_OPTS = {'med', 'abs_med', 'tri', 'rect', 'pg', 'gauss'};%% VALIDATION FUNCTIONSvalidateX = @(input) isnumeric(input) && ...                     (numel(input) > N);                 validateN = @(input) validateattributes(input, ...                    {'numeric'}, ...                    {'scalar','positive','integer'});                 validateType = @(input) any(validatestring(input,TYPE_OPTS));validateEnds = @(input) isnumeric(input) && ...                        isscalar(input) && ...                        ((abs(input)<eps)||abs(input-1)<eps);%% CHECK ARGUMENTSp = inputParser;addRequired(p,'X',validateX);addRequired(p,'N',validateN);addOptional(p,'Type',DEF_TYPE,validateType);addOptional(p,'Ends',DEF_ENDS,validateEnds);parse(p,X,N,varargin{:});Type = p.Results.Type;Ends = p.Results.Ends;switch Type   case 'abs_med'      Y=medsmoother(abs(X),N,Ends);   case 'med'      Y=medsmoother(X,N,Ends);   case 'rect'      Y=smoother(X,N,Ends);   case 'tri'      Y=smoother(smoother(X,N,Ends),N,Ends);   case {'pg', 'gauss'}      Y=smoother(smoother(smoother(X,N,Ends),N,Ends),N,Ends);end%% IMPLEMENT SMOOTHING   function y=smoother(x,n,ends)      % Actually implements the smoothing         SumPoints=sum(x(1:n));      s=zeros(size(x));      halfw=round(n/2);      L=numel(x);      for k=1:L-n        s(k+halfw-1)=SumPoints;        SumPoints=SumPoints-x(k);        SumPoints=SumPoints+x(k+n);      end      s(k+halfw)=sum(x(L-n+1:L));      y=s./n;      % Taper the ends of the signal if ends=1.      if ends==1        startpoint=(n + 1)/2;        y(1)=(x(1)+x(2))./2;        for k=2:startpoint            y(k)=mean(x(1:(2*k-1)));            y(L-k+1)=mean(x(L-2*k+2:L));        end        y(L)=(x(L)+x(L-1))./2;      end   end    function y=medsmoother(x,n,ends)      % Actually implements the smoothing         y=zeros(size(x));      halfw=round(n/2);      L=numel(x);      for k=1:L-n        y(k+halfw-1)=median(x(k:(k+n)));      end      % Taper the ends of the signal if ends=1.      if ends==1        startpoint=(n + 1)/2;        y(1)=(x(1)+x(2))./2;        for k=2:startpoint            y(k)=median(x(1:(2*k-1)));            y(L-k+1)=median(x(L-2*k+2:L));        end        y(L)=(x(L)+x(L-1))./2;      end        endend